const dbdDB = require("dbd.db")
const express = require("express")
const { EventEmitter } = require("events")
const bodyP = require("body-parser")
const cookie = require("cookie-parser")
const passport = require("passport")
const initializePassport = require("./passport-config")
const session = require("express-session")
const flash = require("express-flash")
const bcrypt = require("bcrypt")
const deviceMGR = require("express-device")
const Util = require("./Utils/index")
const SocketIO = require("socket.io")
const HTTP = require("http")

/**
 * The BaseClient of Dashboard, initiating WebPage and Rest API here
 * @class
 * @extends EventEmitter
 */

class BaseClient extends EventEmitter {
  /**The constructor of BaseClient
   * @constructor
   * @param DBDJSClient - The DBD.JS Client
   */

	constructor(DBDJSClient = {}) {

		super()


    /**
     * The DBD.JS Client of BaseClient
     */

		this.bot = DBDJSClient

    this.Util = Util

    /**
     * The Client of BaseClient
     */
		this.client = this.bot.client
		this.db = dbdDB("database")
    this.apiEnabled = false
    this.client.Express = this

		new Promise(async (resolve, reject) => {
			try {
				await this.loadUtils(false)
				resolve(true)
			} catch (err) {
				reject(err)
			}
		})
	}

  async refreshBotCommands() {
    for (const L of Util.sysCMD) {
      this.client[L] = new (require("discord.js")).Collection()
    }

    await this.loadUtils(true)
  }

  loadBotCommands() {
    for (const f of Object.values(Util.botCommands)) {
      if (this.client[f]) {
      for (const cmd of this.client[f].array()) {
        const c = Object.assign(cmd, {callback:Object.keys(Util.botCommands).find(e => Util.botCommands[e] === f)})
      
        this.addCommands(c)
      }
    }
    }
  }

	async loadUtils(isNew) {
		this.collection = await this.db.collection({ name: 'Config' })

		await new Promise(resolve => {
			this.collection._waitForReady.push(resolve)

			if (this.collection.ready) resolve()
		})

		this.commands = (await this.collection.findOne({
			EX: "DBD_COMMANDS"
		}) || { data: [] }).data


    this.ACCOUNTS = (await this.collection.findOne({
      EX:"ACCOUNTS"
    }) || { data: []}).data

    if (!isNew) {
    for (const event of Util.callbacks) {

      this.bot[event]()
    }
    }
    

		Object.assign(this.client.variables, (await this.collection.findOne({
			EX: "DBD_VARIABLES"
		}) || { data: {} }).data)

		this.CMD = []

		if (this.commands.length) {
			let i = 0

			while (i < this.commands.length) {
				try {
					this.client.bot[this.commands[i].callback](this.commands[i])
					this.CMD.push(this.commands[i])
				} catch (err) {
					console.error(err.message)
				}
				i++
			}
		}

		

		this.collection.set({
			EX: "DBD_COMMANDS",
			data: this.CMD
		}, {
				EX: "DBD_COMMANDS"
			})
		this.collection.set({
			EX: "DBD_VARIABLES",
			data: this.client.variables
		}, {
				EX: "DBD_VARIABLES"
			})
	}

  addCommands(...args) {
    for (const d of args) {
      if (typeof d.name !== "string") {
        throw new TypeError("Command name must be typeof String!")
      }

      if (typeof d.callback !== "string") {
        throw new TypeError("Command callback must be typeof String!")
      }

      if (!(d.callback.endsWith("ommand") && this.client.bot[d.callback])) {
				throw new TypeError("Command callback is not Available!")
			}

      if (typeof d.code !== "string") {
        throw new TypeError("Command code must be typeof String!")
      }


      if (d.aliases && (d.aliases instanceof Array) !== true) {
        throw new TypeError("Command aliases must be typeof Array!")
      }
          d["id"] = Date.now()
              this.CMD.push(d)
    }

    try { 
        this.collection.set({
          EX:"DBD_COMMANDS",
          data:this.CMD
        }, {
          EX:"DBD_COMMANDS"
        })
        this.refreshBotCommands()
      } catch (err) {
        throw new Error(err)
      }
  }

  editCommand(target = new Number(), update = {}, callback = (error = new String(), target = new Object(), update = new Object()) => {}) {

    if (typeof callback !== "function") {
      throw new TypeError("Callback must be a Function!")
    }
    if (typeof target !== "number") {
     return callback("target must be typeof Number!")
    }

    const index = this.CMD.findIndex(f => (f.id === target))

    if (index < 0) {
      return callback("Unable to find Index with given Target")
    }

    if (typeof update.name !== "string") {
        return callback("Command name must be typeof String!")
      }

      if (typeof update.callback !== "string") {
        return callback("Command callback must be typeof String!")
      }

      if (!(update.callback.endsWith("ommand") && this.client.bot[update.callback])) {
				return callback("Command callback is not Available!")
			}

      if (typeof update.code !== "string") {
        return callback("Command code must be typeof String!")
      }

      if (update.aliases && typeof update.aliases !== "array") {
        return callback("Command aliases must be typeof Array!")
      }

      update["id"] = this.CMD[index].id

      try {
        this.CMD[index] = update 
        this.collection.set({
          EX:"DBD_COMMANDS",
          data:this.CMD
        }, {
          EX:"DBD_COMMANDS"
        })
        this.refreshBotCommands()
        return callback(null, target, update)
      } catch (err) {
        return callback(err)
      }

  }

  deleteCommand(target = new Number(), callback = (error = new String(), deleted = new Object()) => {}) {
    if (typeof callback !== "function") {
      throw new TypeError("Callback must be typeof Function!")
    }

    if (typeof target !== "number") {
      return callback("target must be typeof Number!")
    }

    const index = this.CMD.findIndex(f => (f.id === target))

    if (index < 0) {
      return callback("Unable to find Index with given Target")
    }

    try {
     delete this.CMD[index] 
     this.collection.set({
          EX:"DBD_COMMANDS",
          data:this.CMD
        }, {
          EX:"DBD_COMMANDS"
        })
        this.refreshBotCommands()
        return callback(null, target)
    } catch (error) {
      return callback(error)
    }
  }

  get Commands() {
    return this.CMD;
  }

  get Variables() {
    return this.client.variables;
  }

  setVariables(data, callback = (error, oldVariables, newVariables) => {}) {
    if (typeof callback !== "function") {
        return callback("Callback must be typeof Function!")
      }

    if (typeof data !== "object") {
     return callback("data must be typeof Object!")
    }


      try {
        callback(null, this.client.variables, data)

				this.client.variables = data
				this.collection.set({
					EX: "DBD_VARIABLES",
					data: this.client.variables
				}, {
						EX: "DBD_VARIABLES"
					})
          
			} catch (err) {
				return callback(err)
			}
    }

  async addAccounts(...args) {
    for (const acc of args) {
      if (typeof acc !== "object") {
        throw new TypeError("One of Accounts is not typeof Object!")
        break;
      }

      if (typeof acc.username !== "string") {
        throw new TypeError("One of Accounts name is not typeof String!")
        break;
      }
      if (typeof acc.password !== "string") {
        throw new TypeError("One of Accounts password is not typeof String!")
        break;
      }

      const hashedPass = await bcrypt.hash(acc.password, 10)
      this.ACCOUNTS.push({
        username:acc.username,
        password:hashedPass,
        id:Date.now()
      })

    }
  

    try {
      this.collection.set({
        EX:"ACCOUNTS",
        data:this.ACCOUNTS
      }, {
        EX:"ACCOUNTS"
      })
    } catch (error) {
      throw new Error(error)
    }
  }

  deleteAccount(target, callback = (error = new String(), deleted = new Object()) => {}) {

      if (typeof callback !== "function") {
        return callback("Callback must be typeof Function!")
      }

      if (typeof target !== "object") {
        return callback("target must be typeof Object!")
      }

      const index = this.ACCOUNTS.findIndex(f => f === target)

      if (index < 0) {
        return callback("No Account was found with Target")
      }

      try {
        callback(null, this.ACCOUNTS[index])

       this.collection.set({
        EX:"ACCOUNTS",
        data:this.ACCOUNTS
      }, {
        EX:"ACCOUNTS"
      })
    } catch (error) {
      return callback(error)
    }

    }

   async updateAccount(target, update, callback = (error = new String(), oldAccount = new Object(), newAccount = new Object()) => {}) {

      if (typeof callback !== "function") {
        return callback("Callback must be typeof Function!")
      }

      if (typeof target !== "object") {
        return callback("target must be typeof Object!")
      }

      const index = this.ACCOUNTS.findIndex(f => f === target)

      if (index < 0) {
        return callback("No Account was found with Target")
      }

      if (typeof update !== "object") {
        return callback("Account is not typeof Object!")
    
      }

      if (typeof update.username !== "string") {
        return callback("Accounts name is not typeof String!")
        
      }
      if (typeof update.password !== "string") {
        return callback("Account password is not typeof String!")
        
      }
      

      const hashedPass = await bcrypt.hash(update.password, 10)
      try {
        callback(null, this.ACCOUNTS[index], {
        username:update.username,
        password:hashedPass,
        id:Date.now()
      })

      this.ACCOUNTS[index] = {
        username:update.username,
        password:hashedPass,
        id:Date.now()
      }

       this.collection.set({
        EX:"ACCOUNTS",
        data:this.ACCOUNTS
      }, {
        EX:"ACCOUNTS"
      })
    } catch (error) {
      return callback(error)
    }

    }

  restartProject() {
      process.on("exit", () => {
          require("child_process").spawn(process.argv.shift(), process.argv, {
                cwd: process.cwd(),
                detached : true,
                stdio: "inherit"
            });
        })

        process.exit()
  }

	async API(options = {
		port: new Number("3000"),
		authorizationKey: new String(),
    debug: new Boolean()
	}) {
		const {port,authorizationKey, debug} = options

		this.port = port
    this.debug = debug

		if (typeof port != 'number' || this.port === 0) {
			new TypeError("Port is not a number or 0, using a random port")

			this.port = Math.floor(Math.random() * 30000)
		}

		if (typeof options.authorizationKey !== "string") throw new TypeError("'authorizationKey' must be typeof string")

    //Initialize Express

		this.express = express()
		this.express.enable("trust proxy")
		this.express.set("view engine", "ejs")
		this.express.set("json spaces", 2)

		this.express.set("views", __dirname + "/views")
    this.express.use(bodyP.urlencoded({extended:false, limit:"10MB"}))
    this.express.use(bodyP.json())
    this.express.use(cookie("lmao_lol_lel_fr_ffffffffffffffffffffffff"))

    this.express.use(express.static(__dirname+"/public"))

    this.express.use(flash())
    this.express.use(session({
      secret:Buffer.from("c2hvdF9sb2xfZGllX21pbmVjcmZ0X2F3ZHF3ZGFzZG5vaWF4Y29haXduZG9xbndkbmFwc2NuYW93bmRwYXdkbg==", "base64").toString(),
      saveUninitialized:false,
      resave:false
    }))
    this.express.use(passport.initialize())
    this.express.use(passport.session())
    this.express.use(deviceMGR.capture())

    this.server = HTTP.createServer(this.express)
    this.socketIO = SocketIO(this.server)

    deviceMGR.enableDeviceHelpers(this.express)

    initializePassport(
      passport, 
      username => this.ACCOUNTS.find(user => user.username === username),
      id => this.ACCOUNTS.find(user => id === user.id)
    )


		//Authorization 
		function Authorize(req, res, next) {
			if (req.headers.authorization === authorizationKey) {
				next()
			} else {
				res.status(401).json({
					message: "401 - Unauthorized"
				})
			}
		}

    //Debug mode 
    function Debug(req, res) {
      if (req.body) {
        console.log("RECEIVED BODY = "+require("util").inspect(req.body))
      } else {
        console.log("NO BODY WAS RECEIVED")
      }
    } 

    if (this.debug === true) {
      this.express.use(Debug)
    } 

		//Application Programming Interface

		//GET
    this.express.get("/api/client", Authorize, (req, res) => {
      res.status(200).json({
        uptime:this.client.uptime,
        client:this.client.user,
        commands:this.CMD,
        variables:this.client.variables,
        events:this.EVENTS,
        users:this.client.users.cache,
        channels:this.client.channels.cache,
        guilds:this.client.guilds.cache
      })
    })
    
		this.express.get("/api/commands", Authorize, (req, res) => {
			res.status(200).json({
				data: this.CMD
			})
		})

		this.express.get("/api/variables", Authorize, (req, res) => {
			res.status(200).json({
				variables: this.client.variables
			})
		})

    this.express.get("/api/accounts", Authorize, (req, res) => {
      res.status(200).json({
        accounts:this.ACCOUNTS
      })
    })

		//POST

    this.express.post("/api/accounts", Authorize, async (req, res) => {
      if (typeof req.body.account !== "object") {
        return res.status(400).json({
          message:"Body.account must be typeof object"
        })

      }

      if (typeof req.body.account.username !== "string") {
        return res.status(400).json({
          message:"Body.account.username must be typeof string"
        })
      }

      if (typeof req.body.account.password !== "string") {
        return res.status(400).json({
          message:"Body.account.password must be typeof string"
        })
      }

      try {

        const hash = await bcrypt.hash(req.body.account.password, 10)
        this.ACCOUNTS.push({
          username:req.body.account.username,
          password:hash,
          id:Date.now()
        })

        const bool = await this.collection.set({
          EX:"ACCOUNTS",
          data:this.ACCOUNTS
        }, {
					EX: "ACCOUNTS"
				})

        if (!bool) new Error("Unable to save Account")

        return res.status(200).json({
          message:"SAVED",
          account:req.body.account
        })

      } catch (error) {
        return res.status(500).json({
          message:"Unexpected Error",
          error:error
        })
      }
    })

		this.express.post("/api/commands", Authorize, (req, res) => {
      
			if (!req.body.command || typeof req.body.command !== "object") {
				return res.status(400).json({
					message: "Body.command must be typeof Object",
					status: "FAILED",
					received_body: req.body.command
				})
			}

			if (!req.body.command.callback || !(req.body.command.callback.endsWith("ommand") && this.client.bot[req.body.command.callback])) {
				return res.status(400).json({
					message: "Body.command.callback is not available"
				})
			}

			if (typeof req.body.command.code != "string") {
				return res.status(400).json({
					message: "Body.command.code must be typeof String"
				})
			}

			if (req.body.command.aliases && typeof req.body.command.name != "array") {
				return res.status(400).json({
					message: "Body.command.aliases must be typeof Array"
				})
			}

      req.body.command["id"] = Date.now()

			try {
				this.CMD.push(req.body.command)
				this.collection.set({
					EX: "DBD_COMMANDS",
					data: this.CMD
				}, {
						EX: "DBD_COMMANDS"
					})
			} catch (err) {
				return res.status(500).json({
					message: "500 - Internal Server Error",
					err: err.message,
					received_body: req.body
				})
			}

      this.refreshBotCommands()

			res.status(202).json({
				status: "SAVED",
				received_body: req.body
			})
		})

		

		this.express.post("/api/variables", Authorize, (req, res) => {
			if (typeof req.body.variables !== "object") {
				return res.status(400).json({
					message: "Body.variables must be typeof Object"
				})
			}
			try {
				this.client.variables = req.body.variables
				this.collection.set({
					EX: "DBD_VARIABLES",
					data: req.body.variables
				}, {
						EX: "DBD_VARIABLES"
					})
			} catch (err) {
				return res.status(500).json({
					message: "500 - Server Internal Error",
					error: err.message,
					status: "FAILED",
					received_body: req.body
				})
			}
			res.status(202).json({
				status: "SAVED",
				received_body: req.body
			})
		})

		//PATCH/UPDATE

    this.express.patch("/api/accounts", Authorize, async (req, res) => {
      if (typeof req.body.target != "string" || typeof req.body.update != "object") {
				return res.status(400).json({
					message: "Body.target must be typeof string (username) and Body.update must be typeof Object"
				})
			}
			const index = this.CMD.findIndex(f => f.username === req.body.target)

			if ( index < 0) {
				return res.status(400).json({
					message: "No Target was same as Body.target"
				})
			}

      try {

        const hash = await bcrypt.hash(req.body.update.password, 10)
       this.ACCOUNTS[index] = {
          username:req.body.update.username,
          password:hash,
          id:Date.now()
        }

        const bool = await this.collection.set({
          EX:"ACCOUNTS",
          data:this.ACCOUNTS
        }, {
					EX: "ACCOUNTS"
				})

        if (!bool) new Error("Unable to save Account")

        return res.status(200).json({
          message:"SAVED",
          account:req.body.account
        })

      } catch (error) {
        return res.status(500).json({
          message:"Unexpected Error",
          error:error
        })
      }

    })

		this.express.patch("/api/commands", Authorize, (req, res) => {
			if (typeof req.body.target !== "number" || typeof req.body.update !== "object") {
				return res.status(400).json({
					message: "Body.target must be the ID of Command and Body.update must be typeof Object"
				})
			}
			const index = this.CMD.findIndex(f => f.id === req.body.target)

			if ( index < 0) {
				return res.status(400).json({
					message: "No Target was same as Body.target"
				})
			}

			if (!req.body.update.callback || !(req.body.update.callback.endsWith("ommand") && this.client.bot[req.body.update.callback])) {
				return res.status(400).json({
					message: "Body.update.callback is not available"
				})
			}

			if (typeof req.body.update.name != "string") {
				return res.status(400).json({
					message: "Body.update.name must be typeof String"
				})
			}

			if (typeof req.body.update.code != "string") {
				return res.status(400).json({
					message: "Body.update.code must be typeof String"
				})
			}

			if (req.body.update.aliases && typeof req.body.update.name != "array") {
				return res.status(400).json({
					message: "Body.update.aliases must be typeof Array"
				})
			}

      req.body.update["id"] = Date.now()
      const target = this.CMD[index]
			try {
        
				this.CMD[index] = req.body.update
				this.collection.set({
					EX: "DBD_COMMANDS",
					data: this.CMD
				}, {
						EX: "DBD_COMMANDS"
					})
			} catch (err) {
				return res.status(500).json({
					message: "500 - Internal Server Error",
					err: err.message,
					received_body: req.body
				})
			}

      this.refreshBotCommands()

			res.status(202).json({
				status: "UPDATED",
				received_body: req.body,
        target:target
			})
		})

		//DELETE 
		this.express.delete("/api/commands", Authorize, (req, res) => {
			if (typeof req.body.target != "number") {
				return res.status(400).json({
					message: "Body.target must be the ID of the Command"
				})
			}
			const index = this.CMD.findIndex(f => f.id === req.body.target)
      if (this.debug === true) {
        console.log("DELETE REQUEST INDEX = "+index)
      }
			if (index < 0) {
				return res.status(400).json({
					message: "No Target was same as Body.target"
				})
			}

      if(!this.CMD[index]) {
        return res.status(400).json({
					message: "No Target exist"
				})
      }


			try {
				delete this.CMD[index]
				this.collection.set({
					EX: "DBD_COMMANDS",
					data: this.CMD
				}, {
						EX: "DBD_COMMANDS"
					})
			} catch (err) {
				return res.status(500).json({
					message: "500 - Internal Server Error",
					err: err.message,
					received_body: req.body
				})
			}

      this.refreshBotCommands()

			res.status(202).json({
				status: "DELETED",
				received_body: req.body
			})
		})

    this.express.delete("/api/restart", Authorize, (req, res) => {

        res.status(202).json({
          message:"ACCEPTED, SHUTDOWN IN 3 SECONDS"
        })
          setTimeout(function() {
        this.restartProject()
        }, 3000)
        

    })

    this.express.delete("/api/accounts", Authorize, (req, res) => {
      if (typeof req.body.target !== "string") {
        return res.status(400).json({
					message: "Body.target must be typeof string (username)"
				})
      }

      const index = this.ACCOUNTS.findIndex(f => f.username === req.body.target)

			if ( index < 0) {
				return res.status(400).json({
					message: "No Target was same as Body.target"
				})
			}

      const account = this.ACCOUNTS[index]

      try {
        this.ACCOUNTS.splice(index, 1)

        this.collection.set({
          EX:"ACCOUNTS",
          data:this.ACCOUNTS
        }, {
					EX:"ACCOUNTS"
				})
      } catch (error) {
        return res.status(500).json({
          message:"Unexpected Error",
          error:error
        })
      }

      return res.status(200).json({
        message:"DELETED",
        deletedAccount:account
      })
    })


		const listener = this.server.listen(this.port, () => console.log("Express is listening to port " + listener.address().port))
    
    this.apiEnabled = true
		this._listener = listener

  this.authorizationKey = authorizationKey

	}

  async createUI() {
    const ACCOUNTS = this.ACCOUNTS
    if (!this.express) {
      throw new Error("API wasn't set!")
    }
    

    this.socketIO.on("connection", socket => {
      socket.on("COMMAND_MODIFY", k => {
       let obj = {}
       for( const prop of k) {
         if (prop.name === "id") {
           obj[prop.name] = new Number(prop.value)

           continue;
         }
         if (prop.name === "aliases") {
           obj[prop.name] = prop.value.trim().split(",")
           continue;
         }
         obj[prop.name] = prop.value
       }
           this.editCommand(parseInt(obj.id), obj, (err) => {

             if (err) {
               this.addCommands(obj)
               
             } else {
               return;
             }
           })
      })
      socket.on("DELETE_COMMAND", id => {
        this.deleteCommand(id, (err) => {
      })
      })

      socket.on("RESART_PROJECT", id => {
       setTimeout(() => {
         this.restartProject()
       }, 3000)
      })

      socket.on("VARIABLES_REMOVE", name => {
        delete this.client.variables[name]
        this.setVariables(this.client.variables)
      })
      socket.on("VARIABLES_MODIFY", data => {
        delete this.client.variables[data.deleteVar]
        this.setVariables(Object.assign(this.client.variables, data.update))
      }) 
    })


    console.log("\x1b[41m\x1b[37mWARNING! WE ARE NOT RESPONSIBLE OF THE CONSEQUENCES\x1b[0m")
    
    this.express.get("/login", checkNotAuthenticated, (req, res) => {
      res.render("Login", {client:this.client.user})
    })

    this.express.get("/", checkAuthenticated, async (req, res) => {
      res.render("botinfo", {user:req.user, bot:this.client, owners: await this.Util.getOwners(this.client)})
      
    })

    this.express.get("/commands", checkAuthenticated, (req, res) => {
      res.render("commandlist", {user:req.user, bot:this.client, commands:this.CMD})
      
    })

    this.express.get("/edit/command/:ids", checkAuthenticated, (req, res) => {
      const index = this.CMD.findIndex(f => f.id === parseInt(req.params.ids))
      
      
      if (req.params.ids === "new") {
        res.render("editcommand", {command:{id:null}, bot:this.client, user:req.user, callbacks:Util.commands, authorizeKey:this.authorizationKey, thisClass:this})
      } else {
      if (index < 0) {
        
       return res.render("404", {errormsg:"Unable to find Command with ID (No Resources was found/exist in the Server)", bot:this.client, user:req.user})
      }

      res.render("editcommand", {command: this.CMD[index], bot:this.client, user:req.user, callbacks:Util.commands, authorizeKey:this.authorizationKey, thisClass:this})
      }
    })

    this.express.get("/variables", checkAuthenticated, (req, res) => {
      res.render("variables", {bot:this.client, user:req.user})
    })

    this.express.get("/edit/variables/:NAME", (req, res) => {
     const exist = this.client.variables[req.params.NAME] 


      if (req.params.NAME === "new") { 
        res.render("editvariable", {user:req.user, bot:this.client, variable:{}})
      } else {
     if (exist) {
       const k = {name:req.params.NAME, value:exist}
       
       res.render("editvariable", {user:req.user, bot:this.client, variable:k})
     } else {
       res.redirect("/404")
     }
      }
    })


    this.express.post("/login", passport.authenticate("local", {
      successRedirect:"/",
      failureFlash:true,
      failureRedirect:"/login"
    }))

    this.express.get("*", checkAuthenticated, (req, res) => {
      res.render("404", {errormsg:"The page you tried to Access is not available", bot:this.client, user:req.user})
    })

    function checkAuthenticated(req, res, next) {
      if (req.user) {
        next()
      } else {
        res.redirect("/login")
      }
    }

    function checkNotAuthenticated(req, res, next) {
      if (!req.user) {
        next()
      } else {
        res.redirect("/")
      }
    }


  }


}


module.exports = BaseClient

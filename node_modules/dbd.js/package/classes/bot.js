const Discord = require("discord.js")

const LocalDatabase = require("dbd.db")

const WorkerPool = require('../handlers/workerPool')

const Database = LocalDatabase("database")

Database.once('ready', () => console.log('Database Ready!'))

const interpreter = require("../interpreter.js")

const Interaction = require("./Interaction") 
const CustomEvent = require("./customEvent.js")
const opts = require("../utils/options")


const shardingClient = require("../handlers/shardingClient.js")
const client = new Discord.Client({
  partials: [
    "CHANNEL",
    "GUILD_MEMBER",
    "MESSAGE", 
    "USER", 
    "REACTION"
  ]
})

client.ytSearch = new WorkerPool(0, {
	filename: require.resolve('../handlers/ytSearch')
}, (meta, id, status) => {
	if (!status) {
		if (meta.message) return

		return Error(meta)
	}

	if (meta.duration) {
		meta.duration.toString = () => {
			return toDuration(meta.duration.seconds)
		}
	} else if (Array.isArray(meta.videos)) {
		let i = 0

		while (i < meta.videos.length) {
			const video = meta.videos[i++]

			if (video.duration) {
				video.duration.toString = () => {
					return toDuration(video.duration.seconds)
				}
			}
		}
	}
})

function toDuration(lengthSeconds) {
	const time = require('parse-ms')(lengthSeconds * 1000)

	const secs = `0${time.seconds % 60}`.substr(-2)
	const mins = `0${time.minutes % 60}`.substr(-2)
	const hours = `0${time.hours % 60}`.substr(-2)
	const iso = [hours, mins, secs]

	if (time.days) iso.unshift(time.days)

	return `${lengthSeconds} Seconds (${iso.join(':')})`
}

client.db = Database.collection({
	name: 'Variables'
})

client.customFunctions = {} 

;(async () => {
	const previousDate = Date.now()
	const previousUsage = process.cpuUsage()
	
	setTimeout(() => {
		const usage = process.cpuUsage(previousUsage)
		const result = 100 * (usage.user + usage.system) / ((Date.now() - previousDate) * 1000)
		
		client.cpu = result
	}, 5000)
})

setInterval(() => {
  const previousDate = Date.now()
  const previousUsage = process.cpuUsage()

	setTimeout(() => {
		const usage = process.cpuUsage(previousUsage)
		const result = 100 * (usage.user + usage.system) / ((Date.now() - previousDate) * 1000)
		
		client.cpu = result
	}, 5000)
}, 5000)

;(async () => {

	if (!client.db.ready) await new Promise(res => {
		client.db._waitForReady.push(res)

		if (client.db.ready) res()

		setTimeout(() => {
			if (client.db.ready) res()
		}, 100)
	})

	console.log(`Database Connected: ${client.db.displayName}`)
})()

const ForceDisconnect = require("../handlers/ForceDisconnect.js")

client.on('voiceStateUpdate',async (oldState, newState) => {
    ForceDisconnect(client, oldState, newState)
    
	const oldChannel = oldState.channel
	const newChannel = newState.channel
	
	if ((oldChannel && !newChannel) || (oldChannel && newChannel && oldChannel.id !== newChannel.id)) {
		if (newState.member.id === newState.client.user.id || (newChannel && oldChannel.id !== newChannel.id && client.user.id === newState.member.id && !newChannel.members.filter(m => !m.user.bot).size)) {
		    if (newChannel) client.emit("musicEnd", client.servers.get(oldChannel.guild.id)), newChannel.leave()
		    
		    return client.servers.delete(oldChannel.guild.id)
		}
		
		const server = newState.client.servers.get(newState.guild.id)
		
		if (server && server.leave && oldChannel.id === oldChannel.guild.me.voice.channelID) {
			if (!client.channels.cache.get(oldChannel.id).members.filter(m => !m.user.bot).size) {
				server.connection.dispatcher.end()
				server.songs = []
			}
		}
	}
})

client._api = (url) => `https://discord.com/api/v8/${url.startsWith("/") ? url.slice(1) : url}`  
//DBD.JS :)
const fs = require("fs") 
client.cpu = 0.013135151890 
client.dbdJSApi = require("../handlers/connectToAPI.js")()
client.loop_commands = new Discord.Collection() 
client.channel_update_commands = new Discord.Collection() 
client.channel_delete_commands = new Discord.Collection() 
client.channel_create_commands = new Discord.Collection() 
client.role_delete_commands = new Discord.Collection() 
client.role_update_commands = new Discord.Collection() 
client.role_create_commands = new Discord.Collection() 
client.presence_commands = new Discord.Collection() 
client.user_update_commands = new Discord.Collection()
client.timeout_commands = new Discord.Collection()
client.typing_commands = new Discord.Collection() 
client.slash_commands = new Discord.Collection()
client.invite_create_commands = new Discord.Collection() 
client.bot_leave_commands = new Discord.Collection() 
client.invite_delete_commands = new Discord.Collection() 
client.ban_add_commands = new Discord.Collection() 
client.ban_remove_commands = new Discord.Collection()
client.music_start_commands = new Discord.Collection()
client.music_end_commands = new Discord.Collection()
client.bot_join_commands = new Discord.Collection()
client.collections = {} 
client.servers = new Discord.Collection()
client.update_commands = new Discord.Collection()
client.join_commands = new Discord.Collection()
client.bot_commands = new Discord.Collection()
client.deleted_commands = new Discord.Collection()
client.ready_commands = new Discord.Collection()
client.variables = {}
client.statuses = new Discord.Collection()
client.leave_commands = new Discord.Collection()
client.awaited_commands = new Discord.Collection()
client.reaction_add_commands = new Discord.Collection()
client.reaction_remove_commands = new Discord.Collection()
client.timeout_pulse_commands = new Discord.Collection() 

const InteractionCreate = require("../events/interactionCreate") 
const InviteCreate = require("../events/inviteCreate") 
const InviteDelete = require("../events/inviteDelete") 
const GuildBanAdd = require("../events/guildBanAdd") 
const GuildBanRemove = require("../events/guildBanRemove") 
const MusicStart = require("../events/musicStart")
const MusicEnd = require("../events/musicEnd")
const GuildCreate = require("../events/guildCreate")
const GuildDelete = require("../events/guildDelete.js")
const MessageUpdate = require("../events/messageUpdate.js")
const Message = require("../events/message.js")
const Ready = require("../events/ready.js")
const MessageDelete= require("../events/messageDelete.js")
const GuildMemberAdd = require("../events/guildMemberAdd.js")
const GuildMemberRemove = require("../events/guildMemberRemove.js")
const MessageReactionAdd = require("../events/messageReactionAdd.js")
const MessageReactionRemove = require("../events/messageReactionRemove.js")

require("../handlers/UpdateWarning")() 


const parser = require("../functions/parser") 
/**
 * The Class that log in the Discord bot to Discord
 * @param options Object The options for logging in
 * @example
 * 
 * 
 *            new Client({token:"Discord Bot Token", prefix:"!"})
 */

class Client {
  constructor(options = {
    sharding: false,
    shardAmount: null, 
    mobile: false, 
    typingStopEvent: false, 
    disabledFunctions: [], 
    fetchInvites: false
  }) {
    if (options.typingStopEvent) client.on("typingStart", (channel, user) => require("../handlers/typingStopHandling")(client, channel, user))
    
    client.bot = this 
    this.client = client
	this.paths = []
    
    //this.loadUtils()

		client.options.fetchInvites = options.fetchInvites
    
    if (Array.isArray(options.disabledFunctions) && options.disabledFunctions.length) {
        options.disabledFunctions.map(func => delete parser[func])
    }
    
    if (options.mobile) {
        Discord.Constants.DefaultOptions.ws.properties.$browser = "Discord Android"
        
        console.log(`Enabled mobile presence`)
    }
    
    if (options.sharding) {
      if (options.shardAmount) {
        client.shards = options.shardAmount
      } else client.shards = "auto"
    
      console.log(`Sharding...`)
    }
     if(options.autoUpdate) {
      require("../handlers/AutoUpdate")()
    }

    if(options.dbhToken === true) client.dbhToken = options.dbhToken;

    if (!options.token) throw new TypeError(`Token wasn't provided.`) 
    
    if (!options.prefix) throw new TypeError(`Prefix wasn't provided.`)
    
    client.prefix = typeof options.prefix === "string" ? [options.prefix] : options.prefix
    
    client.cookie = options.youtubeCookie || "GPS=1; YSC=_qyeNjwA2uQ; VISITOR_INFO1_LIVE=UFcCYjpbsJM; PREF=tz=Asia.Jakarta; SID=7Qc_mHUAHFKDCuc_WDDxC5mIepP_Ih9jmyP8MRAODT6H1-dKvPRiW3LurdpNwQqoBUfhfQ.; __Secure-3PSID=7Qc_mHUAHFKDCuc_WDDxC5mIepP_Ih9jmyP8MRAODT6H1-dK_Td1Sl1SETHN1SY5tELppw.; HSID=AS62nuB1-_rmsKF5o; SSID=Ad-Z3vzEtcs-_NO6u; APISID=6wDQMx1DmZYsDZF6/ANyQsEONW4GfpKJMP; SAPISID=Uuyifc90HbGCQirI/AMluAUpqjHMeFYp85; __Secure-3PAPISID=Uuyifc90HbGCQirI/AMluAUpqjHMeFYp85; YTC=liv|1614579439; SIDCC=AJi4QfGBMa-Ts8R4wDtk8n67vrfI_E9TyGruGbZB1mBIBVUz-oxXfuffG2IJgc0J9YIXm84rwA; __Secure-3PSIDCC=AJi4QfFTWSZB_dfm58p2GPanQsYTnP6YousPSLNeX00KunEoQGMdXHdwJBrrdLoy8esDbRre"

      client.on("musicStart", (server, old) => MusicStart(client, server, old))
    client.on("musicEnd", (server, old) => MusicEnd(client, server, old))
    
    client.on("timeoutPulse", (data) => require("../events/timeoutExpire")(client, data, true)) 
    client.on("timeoutExpire", (data) => require("../events/timeoutExpire")(client, data))
    
    client.login(options.token).catch(err => TypeError(`Invalid token`)) 
        client.once("ready", () => {
                  Ready(client)
       
        })

  } 
  
  //utils loader 
  /*loadUtils() {
      client.util = {} 
      
      for (const Util of fs.readdirSync("./package/utils/")) {
          client.util[Util.replace(".js", "")] = require(`../utils/${Util}`)
      }
  }*/
  
  channelUpdateCommand(d = {}) {
      client.channel_update_commands.set(Math.floor(Math.random() * 5939293959), d) 
  }
    
  channelDeleteCommand(d = {}) {
      client.channel_delete_commands.set(Math.floor(Math.random() * 5939293959), d) 
  }
  
    
  channelCreateCommand(d = {}) {
      client.channel_create_commands.set(Math.floor(Math.random() * 5939293959), d) 
  }
  interactionCommand(d  ={}) {
      client.slash_commands.set(Math.floor(Math.random() * 58288384832), d)
  }
  
  presenceUpdateCommand(d = {}) {
      client.presence_commands.set(Math.floor(Math.random() * 84584839392929), d)
  }
  
  timeoutCommand(d = {}) {
      client.timeout_commands.set(client.timeout_commands.size, d)
  }
  
  roleDeleteCommand(d = {}) {
      client.role_delete_commands.set(Math.floor(Math.random() * 84584839392929), d)
  }
  
  roleCreateCommand(d = {}) {
      client.role_create_commands.set(Math.floor(Math.random() * 95833858483), d )
  }
  
  roleUpdateCommand(d = {}) {
      client.role_update_commands.set(Math.floor(Math.random() * 5993838594992), d) 
  }
  timeoutPulseCommand(ops = {}) {
      client.timeout_pulse_commands.set(client.timeout_pulse_commands.size, ops)
  }
  
  userUpdateCommand(d = {}) {
      client.user_update_commands.set(Math.floor(Math.random() * 5993838594992), d) 
  }
  
  deletedCommand(d = {}) {
    client.deleted_commands.set(Math.floor(Math.random() * 5838838494939), d) 
  }
  
  botJoinCommand(d = {}) {
      client.bot_join_commands.set(Math.floor(Math.random() * 589392939392), d) 
  }
  
  botLeaveCommand(d = {}) {
      client.bot_leave_commands.set(Math.floor(Math.random() * 488384848338), d)
  }

  readyCommand(d = {}) {
    client.ready_commands.set(Math.floor(Math.random() * 5838838494939), d) 
  }

  reactionAddCommand(d = {}) {
    client.reaction_add_commands.set(Math.floor(Math.random() * 5838838494939), d) 
  }

  reactionRemoveCommand(d = {}) {
    client.reaction_remove_commands.set(Math.floor(Math.random() * 5838838494939), d) 
  }
  
  typingStartCommand(ops = {}) {
      client.typing_commands.set(client.typing_commands.size, ops)
  }
  
  banAddCommand(d = {}) {
      client.ban_add_commands.set(Math.floor(Math.random() * 4982838484), d) 
  }
  
  banRemoveCommand(d = {}) {
      client.ban_remove_commands.set(Math.floor(Math.random() * 49588393), d)
  }
  
  inviteCreateCommand(d = {}) {
      client.invite_create_commands.set(Math.floor(Math.random() * 294484839), d)
  }
  
  inviteDeleteCommand(d = {}) {
      client.invite_delete_commands.set(Math.floor(Math.random() * 3949583929), d)
  }
  awaitedCommand(d = {}) {
    client.awaited_commands.set(Math.floor(Math.random() * 5838838494939), d) 
  }
  
  leaveCommand(d = {}) {
    client.leave_commands.set(Math.floor(Math.random() * 5838838494939), d) 
  }
  
  updateCommand(d = {}) {
    client.update_commands.set(Math.floor(Math.random() * 5838838494939), d) 
  }

  musicStartCommand(d = {}) {
      client.music_start_commands.set(Math.floor(Math.random() * 583828848), d) 
  } 
  
  musicEndCommand(d = {}) {
      client.music_end_commands.set(Math.floor(Math.random() * 583828848), d) 
  }
  
  joinCommand(d = {}) {
    
    if (!d.channel) throw new Error(`Join Command ${client.join_commands.size} needs a channel!`)
    
    if (!d.code) throw new Error(`Join Command ${client.join_commands.size} needs a code! `)
    
    d.id = Math.floor(Math.random() * 494993848489)
    
    client.join_commands.set(d.id, d) 
    
  } 
  
  status(d = {
    type: new String(),
    text: new String(),
    time: 12,
    url: new String() 
  }) {
    client.statuses.set(client.statuses.size, d) 
  }
  
  loopCommand(opts = {
      every: null, 
      executeOnStartup: false, 
      channel: null, 
      code: null 
  }) {
      const interval = require("../handlers/loopCommands")(client, opts) 

	  opts.loopInterval = interval
	  
      client.loop_commands.set(client.loop_commands.size, opts)
  }
  command(...args) {
    for (const d of args) {     
    if (!d.name) throw new TypeError(`Command ${client.bot_commands.size} needs a name!`)
    
    if (!d.code) throw new TypeError(`Command ${client.bot_commands.size} needs a code!`)
    
		d.id = Math.floor(Math.random() * 58939248388)
    
    client.bot_commands.set(d.id, d)
    
    }
  } 
  
  //Better loadCommands™️
  async loadCommands(path, debug = true) {
	if (typeof path !== 'string') throw new TypeError(`Expecting typeof string on 'path' parameter, get '${typeof path}' instead`)

	if (!require('path').isAbsolute(path)) path = require('path').resolve(path)

	try {
		if (await fs.promises.stat(path).then(f => !f.isDirectory())) throw new Error('e')
	} catch {
		throw new TypeError('Path is not a valid directory!')
	}

	const index = this.paths.findIndex(d => d.path === path)

    if (index < 0) this.paths.push({
		path, debug
	})

	const validCmds = Object.getOwnPropertyNames(Client.prototype).filter(n => {
		return n.toLowerCase().endsWith('command')
	})

	const dirents = await walk(path)
	const debugs = []

	for (const { name } of dirents) {
		delete require.cache[name]

		let cmds

		try {
			cmds = require(name)
		} catch {
			debugs.push(`| Failed to walk in ${name}`)

			continue
		}
		
		if (cmds == null) {
			debugs.push(`| No data provided in ${name}`)

			continue
		}

		if (!Array.isArray(cmds)) cmds = [cmds]

		debugs.push(`| Walking in ${name}`)

		for (const cmd of cmds) {
			if (!isObject(cmd)) {
				debugs.push(`| Provided data is not an object`)

				continue
			}

			if (!('type' in cmd)) cmd.type = 'command'

			const valid = validCmds.some(c => c === cmd.type)

			if (!valid) {
				debugs.push(`| Invalid command type '${cmd.type}' at ${cmd.name || cmd.channel}`)

				continue
			}

			cmd.load = true
			
			try {
				this[cmd.type](cmd)
			} catch {
				debugs.push(`| Failed to load '${cmd.name || cmd.channel}' (${cmd.type})`)

				continue
			}

			debugs.push(`| Loaded '${cmd.name || cmd.channel}' (${cmd.type})`)
		}
	}

	if (debug) {
		console.log('|------------------------------------------|\n' + debugs.join('\n') + '\n|------------------------------------------|')
	}

	function isObject(data) {
		return data instanceof Object && !Buffer.isBuffer(data) && !Array.isArray(data) && !(data instanceof RegExp)
	}

	async function walk(path) {
		const something = await fs.promises.readdir(path, { withFileTypes: true }).then(f => {
			return f.map(d => {
				d.name = `${path}/${d.name}`

				return d
			})
		})

		const files = something.filter(d => d.isFile())
		const dirs = something.filter(d => d.isDirectory())

		for (const d of dirs) {
			const items = await walk(d.name)

			files.push(...items)
		}

		return files
	}
  }
  

  createCustomEvent(EventEmitter) {
    return new CustomEvent(client, EventEmitter)
  }

  //events 
  //not accurate, might need a few seconds to detect the user, and must be enable within bot instance 
  onTypingStop() {
      client.on("typingStop", (channel, user) => require("../events/typingStop")(client, channel, user))
  }
  //already enabled if typingStopEvent property is set to true 
  onTypingStart() {
      //if (client.options.typingStopEvent) return false 
      
      client.on("typingStart", (channel, user) => require("../events/typingStart")(client, channel, user))
  }
  
  onChannelDelete() {
      client.on("channelDelete", channel => require("../events/channelDelete")(client, channel))
  }
  
  onChannelCreate() {
      client.on("channelCreate" , (channel) => require("../events/channelCreate") (client, channel)) 
  }
  
  onChannelUpdate() {
      client.on("channelUpdate", (oldc, newc) => require("../events/channelUpdate")(client, oldc, newc)) 
  }
  onRoleUpdate() {
      client.on("roleUpdate",(oldr, newr) => require("../events/roleUpdate")(client, oldr, newr)) 
  }
  
  onRoleDelete() {
      client.on("roleDelete", (role) => require("../events/roleDelete")(client, role)) 
  }
  
  onRoleCreate() {
      client.on("roleCreate", (role) => require("../events/roleCreate")(client, role))
  }
  onPresenceUpdate() {
      client.on("presenceUpdate", (oldp, newp) => require("../events/presenceUpdate")(client, oldp, newp))
  }
  onUserUpdate() {
      client.on("userUpdate", (old, newu) => require("../events/userUpdate")(client, old, newu))
  }
  
  onInteractionCreate() {
      client.ws.on("INTERACTION_CREATE", data => {
          InteractionCreate(client, new Interaction(client, data))
      })
  }
  
  onInviteCreate() {
      client.on("inviteCreate", (invite) => InviteCreate(client, invite)) 
  }
  
  onInviteDelete() {
      client.on("inviteDelete", (invite) => InviteDelete(client, invite))
  }
  onBanAdd() {
      client.on("guildBanAdd", (guild, user) => GuildBanAdd(client, guild, user))
  }
  
  onBanRemove() {
      client.on("guildBanRemove", (guild, user) => GuildBanRemove(client, guild, user))
  }
  
  onMessage(options = {
    guildOnly: true,
    respondToBots: false
  }) {

    client.messageEventOptions = options

    client.on("message", async message => {Message(client, message, client.db)} ) 
  } 
  
  onGuildJoin() {
      client.on("guildCreate", (guild) => GuildCreate(client, guild))
  }
  
  onGuildLeave() {
    client.on("guildDelete", (guild) => GuildDelete(client, guild))
  } 
  
  onJoined() {
    client.on("guildMemberAdd", member => GuildMemberAdd(client, member, client.db))
  } 

  onReactionAdd() {
    client.on("messageReactionAdd", (reaction, user) => MessageReactionAdd(client, reaction, user, client.db))
  }

  onReactionRemove() {
    client.on("messageReactionRemove", (reaction, user) => MessageReactionRemove(client, reaction, user, client.db))
  }

  onLeave() {
    client.on("guildMemberRemove", member => GuildMemberRemove(client, member, client.db))
  }

  onMessageUpdate() {
    client.on("messageUpdate", (omsg, msg) => MessageUpdate(client, omsg, msg, client.db))
  }
  
  onMessageDelete() {
    client.on("messageDelete", (msg) => MessageDelete(client, msg, client.db))
  }
  
  variables(op = {}) {
    Object.assign(client.variables, op)
  }
}

String.prototype.deleteBrackets = function() {
  return this
  .replace(/\[/g, "#RIGHT#")
  .replace(/\]/g, "#LEFT#")
  .replace(/;/g, "#SEMI#")
	.replace(/:/g, "#COLON#")
  .replace(/\$/g, "#CHAR#")
  .replace(/>/g, "#RIGHT_CLICK#")
  .replace(/</g, "#LEFT_CLICK#")
  .replace(/=/g, "#EQUAL#")
  .replace(/{/g, "#RIGHT_BRACKET#")
  .replace(/}/g, "#LEFT_BRACKET#")
}

String.prototype.removeBrackets = String.prototype.deleteBrackets

String.prototype.check = function () {
    return this
    .trim().replace(/\t/g, "").split(/ +/g)[0][0]
}

String.prototype.after = function () { 
    const after = this.replace(/(\s|\n)/gmi, '').startsWith('[') ? this.split("[")[1] : undefined
    
    let inside
    
    let total = "" 
    
    let splits = [] 
    
    if (after) {
        inside = after.split("]")[0] 
        
        total = `${this.split("[")[0]}[${inside}${after.includes(']') ? "]" : ""}`
        
        splits = inside.split(";") 
    } 
    
    return {
        inside, 
        total, 
        splits
    }
}

String.prototype.addBrackets = function() {
  return this
  .replace(/#RIGHT#/g, "[")
  .replace(/#LEFT#/g, "]")
  .replace(/#SEMI#/g, ";")
	.replace(/#COLON#/g, ":")
  .replace(/#CHAR#/g, "$")
  .replace(/#RIGHT_CLICK#/g, ">")
  .replace(/#LEFT_CLICK#/g, "<")
  .replace(/#EQUAL#/g, "=")
  .replace(/#RIGHT_BRACKET#/g, "{") 
  .replace(/#LEFT_BRACKET#/g, "}")
}

Array.prototype.goof = function (sep = "_") {
    return this.map(x => x.split(sep).map(w => w.toLowerCase().replace(w[0].toLowerCase(), w[0].toUpperCase())).join(" ")).join(", ")
}

String.prototype.replaceLast = function(find, replace) {
        var index = this.lastIndexOf(find);

        if (index >= 0) {
            return this.substring(0, index) + replace + this.substring(index + find.length);
        }

        return this.toString();
};

module.exports = Client
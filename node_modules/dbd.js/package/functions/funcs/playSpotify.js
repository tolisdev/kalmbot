const djs = require("discord.js")
const embed = require("../../handlers/errors")
const execute = require("../../handlers/MusicPlayer")
const spotify = require('spotify-url-info')
const msp = require("ms-parser")
const pms = require("parse-ms")

var timeout;

module.exports = async d => {
	const code = d.command.code
	const search = d.client.ytSearch
	const inside = code.split("$playSpotify[")[1].split("]")[0]
	let [
		url,
		showsuccess = "",
		time = "1s",
		deafen = false,
		leaveEmpty = "no",
		error = ":x: Error while making the request."
	] = inside.split(";")
	let list = []
	try {
		time = msp(time).ms
	} catch {
		time = msp("1s").ms
	}
	deafen = (deafen === "yes")
	try {
		list = await spotify.getTracks(url.addBrackets())
	} catch (err) {
		return embed(d, error)
	}
	let awaits = []
	let playlist = []

	async function awaitPlays(song, index) {
		var videos = await search.post({ search: `${song.artists[0].name} - ${song.name}` })
		const artistName = song.artists[0].name.split(' ')
		const video = videos.videos.find(vid => artistName.every(n => vid.title.includes(n))) || videos.videos.find(vid => artistName.every(n => vid.author.name.includes(n)))
		if (!video) return null
		const data = {
			title: () => typeof video.title === "string" ? video.title.deleteBrackets() : require("util").inspect(video.title),
			description: () => video.description,
			duration: () => video.duration.toString().split("seconds").join("Seconds"),
			duration_left: (server) => {
				if (!server) return;
				const ms = msp(data.duration().split(" ")[0] + "s").ms
				const time = Math.floor(ms - (server.connection.dispatcher.streamTime + (d.client.servers.get(d.message.guild.id).seek || 0)))
				const ISO = new Date(time).toISOString().substr(11, 11).split(":")

				if (ISO[0] === "00") {
					ISO.shift()
					ISO[1] = Math.floor(parseInt(ISO[1]))

					if (ISO[1].toString().length === 1) ISO[1] = "0" + ISO[1].toString()

				} else {
					ISO[2] = Math.floor(parseInt(ISO[2]))

					if (ISO[2].toString().length === 1) ISO[2] = "0" + ISO[2].toString()
				}

				return `${Math.floor(time / 1000)} Seconds (${ISO.join(":")})`
			},
			current_duration: (server) => {
				if (!server) return

				const ms = server.connection.dispatcher.streamTime + (server.seek || 0)
				const time = pms(ms)

				const secs = `0${time.seconds % 60}`.substr(-2)
				const mins = `0${time.minutes % 60}`.substr(-2)
				const hours = `0${time.hours % 60}`.substr(-2)
				const iso = [hours, mins, secs]

				if (time.days) iso.unshift(time.days)

				return `${Math.floor(ms / 1000)} Seconds (${iso.join(":")})`
			},
			userID: () => d.message.author.id,
			thumbnail: () => video.thumbnail,
			publisher: () => video.author.name,
			publisher_url: () => video.author.url,
			url: () => "https://www.youtube.com/watch?v=" + video.videoId,
			stream: "ytdl",
			prune: false
		}
		playlist[index] = data
	}
	for (let ind = 0; ind < list.length; ind++) {
		awaits.push(awaitPlays(list[ind], ind))
	}
	await Promise.all(awaits)

	playlist = playlist.filter(() => true)

	const server = d.client.servers.get(d.message.guild.id)

	if (!server && playlist.length) {
		const vc = d.message.member.voice.channel

		if (!vc) return embed(d, error);

		; (async () => {
			const connection = vc.join().catch(err => {
				console.error("I was unable to Join, Reason: \n" + err)
				embed(d, "I was unable to join, Error: " + err.message)
			})

			const constructor = {
				voice: d.message.member.voice.channel,
				connection: connection,
				songs: playlist,
				loopSong: false,
				loopQueue: false,
				volume: null,
				text: d.message.channel,
				playing: true,
				state: "ENDED",
				vc_legacy: time,
				deafen: deafen,
				pruneEnabled: false,
				leave: leaveEmpty === "yes"
			}
			constructor.volume = 100
			d.client.servers.set(d.message.guild.id, constructor)

			try {
				await execute(d, true, error)
			} catch (err) {
				console.log(err)

				return embed(d, error)
			}
		})()
	} else {
		server.songs.push(...playlist)
		d.client.servers.set(d.message.guild.id, server)
		if (server.state === "ENDED") {
			execute(d, true, error).catch(err => {
				console.error(err)

				embed(d, error)
			})
		}
	}

	if (showsuccess.toLowerCase() === "number") {
		return {
			code: code.replaceLast(`$playSpotify[${inside}]`, playlist.length + "/" + list.length)
		}
	} else if (showsuccess.toLowerCase() === "name") {
		return {
			code: code.replaceLast(`$playSpotify[${inside}]`, playlist.map(song => song.title()).join(", "))
		}
	} else {
		return {
			code: code.replaceLast(`$playSpotify[${inside}]`, "")
		}
	}
}
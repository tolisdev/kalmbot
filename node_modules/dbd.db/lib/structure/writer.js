const fs = require("fs")
const DBDError = require('./dbdError')
const Bison = require('../bison')
const Bluebird = require('bluebird')
const { EventEmitter } = require("events")
const { Readable } = require('stream')

class Writer extends EventEmitter {
	constructor(db, collection) {
		super()

		this._waitForReady = []

		this.run = false
		this.queue = false
		this.db = db
		this.collection = collection

		super.on('ready', async () => {
			let i = 0

			while (i < this._waitForReady.length) {
				const resolve = this._waitForReady.shift()

				resolve()

				this.queue = false

				i++
			}
		})

		super.on('exec', async () => {
			if (this.queue) return

			if (this.run) {
				if (this.queue) return

				this.queue = true

				await new Bluebird(resolve => {
					this._waitForReady.push(resolve)

					if (!this.run) resolve()

					setTimeout(() => { if (!this.run) resolve() }, 50)
				})
			}

			if (this.collection.closed) return

			this.run = true

			const parallel = new EventEmitter()

			parallel.on('finish', check => {
				if (check === 3) {
					this.emit('ready')

					this.run = false

					parallel.removeAllListeners('finish')
				}
			})

			let parallels = 1

			const data = {
				cache: this.db.cache.get(collection.displayName),
				indexes: this.collection.indexes,
				ttl: this.collection.ttls
			}

			this.stringify(data.indexes, `${this.db.name}/${this.collection.displayName}.meta`).then(() => {
				parallel.emit('finish', parallels++)
			})

			if (this.collection.ttl >= 5 && data.ttl.length) {
				this.stringify(data.ttl, `${this.db.name}/${this.collection.displayName}.ttl`).then(() => {
					parallel.emit('finish', parallels++)
				})
			} else {
				parallel.emit('finish', parallels++)
			}

			this.stringify(data.cache, `${this.db.name}/${this.collection.name}`).then(() => {
				parallel.emit('finish', parallels++)
			})
		})
	}

	/** 
	 	* @param {!Array} data The data
	 	* @param {!Writable} readable The writable stream
	 	* @param {!Boolean} isData Wether or not the data is collection data
		* @returns {String}
		*/
	async stringify(data, file) {
		if (!(data instanceof Object)) throw new DBDError('Data must be an object!', 6)

		const string = await this.db.json.stringify(data).then(str => str.substr(1, str.length-2))
		const encoded = await Bison.encode(string)

		const readable = new Readable({
			read: () => { },
			encoding: 'utf8'
		})

		const writable = fs.createWriteStream(file)

		setImmediate(() => {
			readable.push(encoded)
			readable.push(null)

			readable.pipe(writable)
		})

		await new Bluebird(res => {
			writable.once('finish', res)
		})
	}
}

module.exports = Writer